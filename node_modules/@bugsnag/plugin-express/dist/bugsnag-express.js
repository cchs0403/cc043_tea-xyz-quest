(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.bugsnagExpress = f()}})(function(){var define,module,exports;
// extends helper from babel
// https://github.com/babel/babel/blob/916429b516e6466fd06588ee820e40e025d7f3a3/packages/babel-helpers/src/helpers.js#L377-L393
var _$assign_2 = function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var _$cloneClient_1 = {};
/* removed: var _$assign_2 = require('./es-utils/assign'); */;

var onCloneCallbacks = [];

_$cloneClient_1 = function (client) {
  var clone = new client.Client({}, {}, [], client._notifier);
  clone._config = client._config; // changes to these properties should not be reflected in the original client,
  // so ensure they are are (shallow) cloned

  clone._breadcrumbs = client._breadcrumbs.slice();
  clone._metadata = _$assign_2({}, client._metadata);
  clone._features = [].concat(client._features);
  clone._featuresIndex = _$assign_2({}, client._featuresIndex);
  clone._user = _$assign_2({}, client._user);
  clone._context = client._context;
  clone._cbs = {
    e: client._cbs.e.slice(),
    s: client._cbs.s.slice(),
    sp: client._cbs.sp.slice(),
    b: client._cbs.b.slice()
  };
  clone._logger = client._logger;
  clone._delivery = client._delivery;
  clone._sessionDelegate = client._sessionDelegate;
  onCloneCallbacks.forEach(function (callback) {
    callback(clone);
  });
  return clone;
};

_$cloneClient_1.registerCallback = function (callback) {
  onCloneCallbacks.push(callback);
};

// Given a host object, return the value at host[key] if it is an object
// and it has at least one key/value
var _$extractObject_3 = function (host, key) {
  if (host[key] && typeof host[key] === 'object' && Object.keys(host[key]).length > 0) {
    return host[key];
  } else {
    return undefined;
  }
};

/* removed: var _$extractObject_3 = require('@bugsnag/core/lib/extract-object'); */;

var _$requestInfo_5 = function (req) {
  var connection = req.connection;
  var address = connection && connection.address && connection.address();
  var portNumber = address && address.port;
  var port = !portNumber || portNumber === 80 || portNumber === 443 ? '' : ":" + portNumber;
  var protocol = typeof req.protocol !== 'undefined' ? req.protocol : req.connection.encrypted ? 'https' : 'http';
  var hostname = (req.hostname || req.host || req.headers.host || '').replace(/:\d+$/, '');
  var url = protocol + "://" + hostname + port + req.url;
  var request = {
    url: url,
    path: req.path || req.url,
    httpMethod: req.method,
    headers: req.headers,
    httpVersion: req.httpVersion
  };
  request.params = _$extractObject_3(req, 'params');
  request.query = _$extractObject_3(req, 'query');
  request.body = _$extractObject_3(req, 'body');
  request.clientIp = req.ip || (connection ? connection.remoteAddress : undefined);
  request.referer = req.headers.referer || req.headers.referrer;

  if (connection) {
    request.connection = {
      remoteAddress: connection.remoteAddress,
      remotePort: connection.remotePort,
      bytesRead: connection.bytesRead,
      bytesWritten: connection.bytesWritten,
      localPort: portNumber,
      localAddress: address ? address.address : undefined,
      IPVersion: address ? address.family : undefined
    };
  }

  return request;
};

var _$express_4 = {};
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

/* eslint node/no-deprecated-api: [error, {ignoreModuleItems: ["domain"]}] */
var domain = require("domain");

/* removed: var _$requestInfo_5 = require('./request-info'); */;

/* removed: var _$cloneClient_1 = require('@bugsnag/core/lib/clone-client'); */;

var handledState = {
  severity: 'error',
  unhandled: true,
  severityReason: {
    type: 'unhandledErrorMiddleware',
    attributes: {
      framework: 'Express/Connect'
    }
  }
};
_$express_4 = {
  name: 'express',
  load: function (client) {
    var requestHandler = function (req, res, next) {
      var dom = domain.create(); // Get a client to be scoped to this request. If sessions are enabled, use the
      // resumeSession() call to get a session client, otherwise, clone the existing client.

      var requestClient = client._config.autoTrackSessions ? client.resumeSession() : _$cloneClient_1(client); // attach it to the request

      req.bugsnag = requestClient; // extract request info and pass it to the relevant bugsnag properties

      requestClient.addOnError(function (event) {
        var _getRequestAndMetadat = getRequestAndMetadataFromReq(req),
            metadata = _getRequestAndMetadat.metadata,
            request = _getRequestAndMetadat.request;

        event.request = _extends({}, event.request, request);
        event.addMetadata('request', metadata);
      }, true);
      if (!client._config.autoDetectErrors) return next(); // unhandled errors caused by this request

      dom.on('error', function (err) {
        var event = client.Event.create(err, false, handledState, 'express middleware', 1);

        req.bugsnag._notify(event, function () {}, function (e, event) {
          if (e) client._logger.error('Failed to send event to Bugsnag');

          req.bugsnag._config.onUncaughtException(err, event, client._logger);
        });

        if (!res.headersSent) {
          res.statusCode = 500;
          res.end('Internal server error');
        }
      });
      return dom.run(next);
    };

    var errorHandler = function (err, req, res, next) {
      if (!client._config.autoDetectErrors) return next(err);
      var event = client.Event.create(err, false, handledState, 'express middleware', 1);

      var _getRequestAndMetadat2 = getRequestAndMetadataFromReq(req),
          metadata = _getRequestAndMetadat2.metadata,
          request = _getRequestAndMetadat2.request;

      event.request = _extends({}, event.request, request);
      event.addMetadata('request', metadata);

      if (req.bugsnag) {
        req.bugsnag._notify(event);
      } else {
        client._logger.warn('req.bugsnag is not defined. Make sure the @bugsnag/plugin-express requestHandler middleware is added first.');

        client._notify(event);
      }

      next(err);
    };

    return {
      requestHandler: requestHandler,
      errorHandler: errorHandler
    };
  }
};

var getRequestAndMetadataFromReq = function (req) {
  var _extractRequestInfo = _$requestInfo_5(req),
      body = _extractRequestInfo.body,
      requestInfo = _objectWithoutPropertiesLoose(_extractRequestInfo, ["body"]);

  return {
    metadata: requestInfo,
    request: {
      body: body,
      clientIp: requestInfo.clientIp,
      headers: requestInfo.headers,
      httpMethod: requestInfo.httpMethod,
      url: requestInfo.url,
      referer: requestInfo.referer
    }
  };
};

_$express_4["default"] = _$express_4;

return _$express_4;

});
//# sourceMappingURL=bugsnag-express.js.map
