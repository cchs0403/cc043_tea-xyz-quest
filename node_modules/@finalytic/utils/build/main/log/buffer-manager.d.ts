import type { Context, LogLevel, LogLine, LogMessage, LogOptions } from './types';
export declare function setDefaultLogOptions(options: Partial<LogOptions>): void;
export declare class Log {
    protected context: Context;
    readonly _log: (message: any, context?: Context, level?: LogLevel) => void;
    constructor(context: Context, _log: (message: any, context?: Context, level?: LogLevel) => void);
    getContext: () => Context;
    replaceContext: (newContext: Context) => void;
    addContext: (newContext: Context) => void;
    child: (newContext: Context) => Log;
    error: (message: any, context?: Context) => void;
    warn: (message: any, context?: Context) => void;
    debug: (message: any, context?: Context) => void;
    info: (message: any, context?: Context) => void;
    log: (message: any, context?: Context) => void;
}
export declare class Logger extends Log {
    private readonly options;
    buffer: LogLine[];
    retryCount: number;
    backOffInterval: number;
    loggerError: boolean;
    timer?: any;
    getOptions: () => LogOptions;
    constructor(options?: LogOptions, initialContext?: Context);
    lastTime: number;
    captureMessage: ({ level, message, context }: LogMessage) => void;
    captureError: (error: any, context: Context, isUnhandledRejection?: boolean) => void;
    generateLogLine: ({ level, message, context, error, disableStacktrace, }: LogMessage) => void;
    timeout: () => number | undefined;
    splitAndFlush: (logLines: LogLine[]) => Promise<void>;
    flush: (lines?: LogLine[]) => Promise<void>;
    process: (lines: LogLine | LogLine[]) => Promise<void>;
    send: (lines: LogLine[]) => Promise<void>;
}
