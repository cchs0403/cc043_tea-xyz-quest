"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = exports.Log = exports.setDefaultLogOptions = void 0;
const utils_1 = require("../utils");
const constants_1 = require("./constants");
const utils_2 = __importDefault(require("./utils"));
const isUnderByteLimit = (buffer) => utils_2.default.jsonByteSize(buffer) < constants_1.FLUSH_BYTE_LIMIT;
const defaultOptions = (0, utils_1.ensure)({
    url: constants_1.DEFAULT_INGESTION_URL,
    hostname: 'function',
    flushInterval: constants_1.LOG_LINE_FLUSH_TIMEOUT,
    enableStacktrace: true,
    sampleRate: constants_1.SAMPLE_RATE,
    tags: [],
    app: '',
    type: 'pretty',
});
let defaultOptionsOverwrite = undefined;
function setDefaultLogOptions(options) {
    defaultOptionsOverwrite = options;
}
exports.setDefaultLogOptions = setDefaultLogOptions;
class Log {
    constructor(context, _log) {
        this.context = context;
        this._log = _log;
        this.getContext = () => this.context;
        this.replaceContext = (newContext) => {
            this.context = { ...newContext };
        };
        this.addContext = (newContext) => {
            this.context = { ...this.context, ...newContext };
        };
        this.child = (newContext) => {
            return new Log({ ...this.context, ...newContext }, this.log);
        };
        this.error = (message, context = {}) => {
            this._log(message, { ...this.context, ...context }, 'error');
        };
        this.warn = (message, context = {}) => {
            this._log(message, { ...this.context, ...context }, 'warn');
        };
        this.debug = (message, context = {}) => {
            this._log(message, { ...this.context, ...context }, 'debug');
        };
        this.info = (message, context = {}) => {
            this._log(message, { ...this.context, ...context }, 'info');
        };
        this.log = (message, context = {}) => {
            this._log(message, { ...this.context, ...context }, 'log');
        };
    }
}
exports.Log = Log;
class Logger extends Log {
    constructor(options = {}, initialContext) {
        const context = initialContext || options.defaultContext || {};
        super(context, (message, context, level = 'log') => {
            if (`${message}`.includes('Warning: Setting the NODE_TLS_REJECT_UNAUTHORIZED'))
                return;
            if (`${message}`.includes('ExperimentalWarning: The Fetch API is an experimental feature.'))
                return;
            this.captureMessage({
                level,
                message,
                context,
            });
        });
        this.options = options;
        this.buffer = [];
        this.retryCount = 0;
        this.backOffInterval = 0;
        this.loggerError = false;
        this.getOptions = () => ({
            ...defaultOptions,
            ...defaultOptionsOverwrite,
            ...this.options,
        });
        this.lastTime = Date.now();
        this.captureMessage = ({ level = 'log', message, context = {} }) => {
            if (message instanceof Error) {
                this.captureError(message, context);
                return;
            }
            this.generateLogLine({ level, message, context });
        };
        this.captureError = (error, context, isUnhandledRejection = false) => {
            let message = error.name
                ? `${error.name}: ${error.message}`
                : error.message;
            if (isUnhandledRejection) {
                message = `Uncaught (in promise) ${message}`;
            }
            this.generateLogLine({
                level: 'error',
                message,
                error: {
                    colno: error.columnNumber || error.colno || error.colNo,
                    lineno: error.lineNumber || error.lineno || error.lineNo,
                    stacktrace: error.stack || error.stacktrace,
                    source: error.fileName || error.source,
                },
                context,
                disableStacktrace: !!(error.stack || error.stacktrace), // Don't generate a second stacktrace for errors since they already have it
            });
        };
        this.generateLogLine = ({ level = 'log', message, context, error = null, disableStacktrace = false, }) => {
            const opts = this.getOptions();
            if (opts.type === 'off')
                return;
            if (opts.type === 'pretty') {
                const lastTime = this.lastTime;
                this.lastTime = Date.now();
                const error = message;
                utils_2.default.originalConsole[level](...[
                    `[${this.getOptions().hostname}/${this.getOptions().app}] [${new Date().toISOString()} +${this.lastTime - lastTime}ms]`,
                    message instanceof Error
                        ? {
                            message,
                            colno: error.columnNumber || error.colno || error.colNo,
                            lineno: error.lineNumber || error.lineno || error.lineNo,
                            stacktrace: error.stack || error.stacktrace,
                            source: error.fileName || error.source,
                        }
                        : message,
                    // context,
                ]
                    .filter((i) => i !== undefined)
                    .map((x) => typeof x === 'object' ? utils_2.default.stringify(x, null, 2) : x));
            }
            else {
                // run the beforeSend hooks
                const data = (opts.hooks || { beforeSend: [] }).beforeSend.reduce((acc, fn) => (acc == null ? null : fn(acc)), {
                    level,
                    message,
                    context,
                });
                // beforeSend stopped the log
                if (data == null) {
                    return;
                }
                const logMessage = typeof data.message === 'string'
                    ? data.message
                    : utils_2.default.stringify(data.message);
                const line = {
                    timestamp: Math.floor(Date.now() / 1000),
                    app: opts.app,
                    level: data.level,
                    meta: context || {},
                };
                if (error)
                    line.meta.error = error;
                // if (context && Object.keys(context).length) line.meta.context = context;
                if (!disableStacktrace && opts.enableStacktrace)
                    line.meta.stacktrace = utils_2.default.getStackTrace();
                if (opts.type === 'stdout')
                    utils_2.default.originalConsole.log(JSON.stringify({ message: logMessage, ...line }));
                else
                    this.process({ line: logMessage, ...line });
            }
        };
        this.timeout = () => {
            if (this.retryCount > 0) {
                this.backOffInterval = utils_2.default.backOffWithJitter(constants_1.STARTING_BACK_OFF, constants_1.MAX_BACK_OFF, this.backOffInterval || constants_1.STARTING_BACK_OFF);
                return this.backOffInterval;
            }
            return constants_1.LOG_LINE_FLUSH_TIMEOUT;
        };
        this.splitAndFlush = async (logLines) => {
            const lines = [...logLines];
            const half = Math.floor(lines.length / 2);
            const lines2 = lines.splice(half);
            this.flush(lines);
            this.flush(lines2);
        };
        this.flush = async (lines) => {
            if (!lines) {
                lines = [...this.buffer];
                this.buffer = [];
            }
            if (!lines.length)
                return;
            if (isUnderByteLimit(lines)) {
                await this.send(lines);
            }
            else if (lines.length === 1) {
                internalErrorLogger(`LogDNA Browser Logger was unable to send the previous log lines because the log size was greater than ${constants_1.FLUSH_BYTE_LIMIT} bytes`);
            }
            else {
                await this.splitAndFlush(lines);
            }
        };
        this.process = async (lines) => {
            if (Array.isArray(lines)) {
                this.buffer = this.buffer.concat(lines);
            }
            else {
                this.buffer.push(lines);
            }
            if (this.timer) {
                clearTimeout(this.timer);
            }
            if (!isUnderByteLimit(this.buffer)) {
                return await this.flush();
            }
            this.timer = setTimeout(async () => {
                await this.flush();
                this.timer = undefined;
            }, this.timeout());
        };
        this.send = async (lines) => {
            const opts = this.getOptions();
            if (this.loggerError) {
                return;
            }
            const params = [
                ['hostname', opts.hostname],
                ['now', `${Date.now()}`],
            ];
            if (opts.tags?.length)
                params.push(['tags', opts.tags]);
            const ingestUrlParams = new URLSearchParams(params);
            const ingestUrl = `${opts.url}?${ingestUrlParams}`;
            const errorMsg = 'Unable to send previous logs batch to LogDNA';
            try {
                const response = await fetch(ingestUrl, {
                    method: 'POST',
                    //keepalive: true,
                    headers: {
                        Authorization: `Basic ${btoa(`${opts.ingestionKey}:`)}`,
                        'Content-Type': 'application/json',
                        Accept: 'application/json',
                    },
                    body: utils_2.default.stringify({ lines }),
                });
                if (response.ok) {
                    this.retryCount = 0;
                    this.backOffInterval = 0;
                }
                else {
                    if (response.status >= 400 && response.status < 500) {
                        internalErrorLogger(`${errorMsg}: ${response.statusText}`);
                    }
                    else if (response.status >= 500) {
                        this.retryCount = this.retryCount + 1;
                        if (this.retryCount > constants_1.MAX_FETCH_ERROR_RETRY) {
                            internalErrorLogger(`${errorMsg}: ${response.statusText}`);
                        }
                        else {
                            await this.process(lines);
                        }
                    }
                }
            }
            catch (error) {
                // If we have any issues sending logs shut down the service immediately
                // This is to avoid ending up in a circular loop of error logs and causing app
                // performance issues or ddos-ing out api.
                this.loggerError = true;
                internalErrorLogger(`LogDNA Browser Logger is unable to send logs to LogDNA.
        Possible issues:
         - Ingestion key is incorrect
         - The configured LogDNA ingestion url is incorrect
         - LogDNA ingestion endpoint is down. https://status.logdna.com/

         Error: ${error.message}
        `);
            }
        };
    }
}
exports.Logger = Logger;
const internalErrorLogger = (message) => {
    console.error(message);
};
