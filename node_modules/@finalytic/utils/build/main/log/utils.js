"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fast_safe_stringify_1 = __importDefault(require("fast-safe-stringify"));
const constants_1 = require("./constants");
const validateHostname = (hostname) => constants_1.HOSTNAME_CHECK.test(hostname);
const parseTags = (tags = []) => {
    if ((typeof tags !== 'string' && !Array.isArray(tags)) ||
        (Array.isArray(tags) && tags.some((tag) => typeof tag !== 'string'))) {
        throw new Error('LogDNA Browser Logger `tags` must be a string or an array of strings');
    }
    if (typeof tags === 'string') {
        tags = [tags];
    }
    return [constants_1.DEFAULT_TAG, ...tags].filter((tag) => tag !== '').join(',');
};
const stringify = (...args) => (0, fast_safe_stringify_1.default)(...args);
const getStackTrace = () => {
    const stack = new Error().stack || '';
    const array = stack
        .split('\n')
        .map((line) => line.trim().substring(3))
        .filter((line, i) => i !== 0 &&
        !line.startsWith('Logger2.') &&
        !line.startsWith('console.') &&
        !line.startsWith('Logger.') &&
        !line.startsWith('Log.') &&
        !line.includes('@finalytic/function') &&
        !line.startsWith('Object.getStackTrace'));
    return array.join('\n');
};
const _randomBetween = (min, max) => {
    return Math.floor(Math.random() * (max - min + 1)) + min;
};
/**
 * This implements exponential backoff with "decorrelated jitter" for use in
 * failing HTTP calls and their retries.  Although the HTTP calls shouldn't be in
 * contention with other clients, the jitter will help alleviate a flood
 * of connections to the server in the event LogDNA suddenly comes back
 * online after being unavailable.
 *
 * @see https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/
 *
 * @param   {Number} base The base sleep time to be used
 * @param   {Number} cap The maximum sleep time allowable in milliseconds
 * @param   {Number} lastSleep The last (or starting) sleep time used
 * @returns {Number} calculated sleep time
 */
const backOffWithJitter = (base, cap, lastSleep) => Math.min(cap, _randomBetween(base, lastSleep * 3));
const jsonByteSize = (obj) => {
    const stringified = stringify(obj);
    if (typeof Blob !== 'undefined')
        return new Blob([stringified]).size;
    return Buffer.byteLength(stringified, 'utf8');
};
const consoleMethods = ['log', 'error', 'debug', 'warn', 'info'];
let cachedConsole = consoleMethods.reduce((a, method) => {
    a[method] = console[method];
    return a;
}, {});
const originalConsole = consoleMethods.reduce((a, m) => {
    a[m] = (...args) => {
        cachedConsole[m](...args);
    };
    return a;
}, {});
// This will delay the caching of the original instance of the console
// until after logdna is enabled and initialized for use with SSR.
const cacheConsole = () => {
    const { log, error, debug, warn, info } = console;
    cachedConsole = { log, error, debug, warn, info };
};
cacheConsole();
exports.default = {
    jsonByteSize,
    validateHostname,
    parseTags,
    stringify,
    getStackTrace,
    backOffWithJitter,
    originalConsole,
};
