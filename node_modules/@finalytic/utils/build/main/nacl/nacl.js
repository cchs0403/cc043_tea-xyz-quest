"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsymmetricCrypto = exports.SymmetricCrypto = void 0;
const blake2b_1 = __importDefault(require("blakejs/blake2b"));
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const tweetnacl_util_1 = __importDefault(require("tweetnacl-util"));
const { box, randomBytes, secretbox } = tweetnacl_1.default;
const { decodeBase64, decodeUTF8, encodeBase64, encodeUTF8 } = tweetnacl_util_1.default;
const newNonce = (length = secretbox.nonceLength) => randomBytes(length);
class SymmetricCrypto {
    static fromPassphrase(secret) {
        return new SymmetricCrypto(hash([decodeUTF8(secret)], secretbox.keyLength));
    }
    static fromSecretKey(key) {
        return new SymmetricCrypto(key);
    }
    static fromNew() {
        return new SymmetricCrypto();
    }
    get secretKey() {
        return encodeBase64(this._secretKey);
    }
    // private _sharedKeys: { [key: string]: Uint8Array };
    constructor(secretKey) {
        // this._sharedKeys = {};
        if (typeof secretKey === 'string') {
            this._secretKey = decodeBase64(secretKey);
        }
        else if (secretKey) {
            this._secretKey = secretKey;
        }
        else {
            this._secretKey = newNonce(secretbox.keyLength);
        }
    }
    static async seal(json, secretKey) {
        const crypto = typeof secretKey === 'string'
            ? SymmetricCrypto.fromPassphrase(secretKey)
            : SymmetricCrypto.fromSecretKey(secretKey);
        const result = await crypto.seal(json);
        crypto.destroy();
        return result;
    }
    async seal(json) {
        const nonce = newNonce();
        const messageUint8 = decodeUTF8(JSON.stringify(json));
        const box = secretbox(messageUint8, nonce, this._secretKey);
        const fullMessage = new Uint8Array(nonce.length + box.length);
        fullMessage.set(nonce);
        fullMessage.set(box, nonce.length);
        const base64FullMessage = encodeBase64(fullMessage);
        return base64FullMessage;
    }
    async open(messageWithNonce) {
        const messageWithNonceAsUint8Array = decodeBase64(messageWithNonce);
        const nonce = messageWithNonceAsUint8Array.slice(0, secretbox.nonceLength);
        const message = messageWithNonceAsUint8Array.slice(secretbox.nonceLength, messageWithNonce.length);
        const decrypted = secretbox.open(message, nonce, this._secretKey);
        if (!decrypted) {
            throw new Error('Could not decrypt message');
        }
        const base64DecryptedMessage = encodeUTF8(decrypted);
        return JSON.parse(base64DecryptedMessage);
    }
    destroy() {
        zero(this._secretKey);
    }
}
exports.SymmetricCrypto = SymmetricCrypto;
class AsymmetricCrypto {
    static fromSecret(secret) {
        return new AsymmetricCrypto(hash([decodeUTF8(secret)], box.secretKeyLength));
    }
    static fromBase64(key) {
        return new AsymmetricCrypto(key);
    }
    static fromEmpty() {
        return new AsymmetricCrypto();
    }
    static fromArray(key) {
        return new AsymmetricCrypto(key);
    }
    get publicKey() {
        return encodeBase64(this._publicKey);
    }
    set publicKey(value) {
        this._publicKey = decodeBase64(value);
    }
    get secretKey() {
        return encodeBase64(this._secretKey);
    }
    // private _sharedKeys: { [key: string]: Uint8Array };
    constructor(secretKey) {
        // this._sharedKeys = {};
        if (typeof secretKey === 'string') {
            secretKey = decodeBase64(secretKey);
        }
        const pair = secretKey
            ? box.keyPair.fromSecretKey(secretKey)
            : box.keyPair();
        this._publicKey = pair.publicKey;
        this._secretKey = pair.secretKey;
    }
    static async seal(json, publicKey) {
        const crypto = AsymmetricCrypto.fromEmpty();
        const result = await crypto.seal(json, publicKey);
        crypto.destroy();
        return result;
    }
    async seal(json, publicKey) {
        if (typeof publicKey === 'string') {
            publicKey = decodeBase64(publicKey);
        }
        const nonce = hash([this._publicKey, publicKey]);
        const messageUint8 = decodeUTF8(JSON.stringify(json));
        const encrypted = box(messageUint8, nonce, publicKey, this._secretKey);
        const fullMessage = new Uint8Array(this._publicKey.length + encrypted.length);
        fullMessage.set(this._publicKey);
        fullMessage.set(encrypted, this._publicKey.length);
        return encodeBase64(fullMessage);
    }
    async open(messageWithNonce) {
        const messageWithNonceAsUint8Array = decodeBase64(messageWithNonce);
        const publicKey = messageWithNonceAsUint8Array.subarray(0, box.publicKeyLength);
        const nonce = hash([publicKey, this._publicKey]);
        const message = messageWithNonceAsUint8Array.subarray(box.publicKeyLength);
        const decrypted = box.open(message, nonce, publicKey, this._secretKey);
        // console.log("public/secret key", this._publicKey, this._secretKey)
        if (!decrypted) {
            throw new Error('Could not decrypt message');
        }
        const base64DecryptedMessage = encodeUTF8(decrypted);
        return JSON.parse(base64DecryptedMessage);
    }
    destroy() {
        zero(this._secretKey);
        zero(this._publicKey);
    }
}
exports.AsymmetricCrypto = AsymmetricCrypto;
function zero(buf) {
    for (let i = 0; i < buf.length; i++) {
        buf[i] = 0;
    }
}
function hash(keys, nonceLength = box.nonceLength) {
    const state = blake2b_1.default.blake2bInit(nonceLength, null);
    for (const key of keys) {
        blake2b_1.default.blake2bUpdate(state, key);
    }
    return blake2b_1.default.blake2bFinal(state);
}
/*
(async () => {
})();
*/
