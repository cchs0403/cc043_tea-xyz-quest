"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.diff = void 0;
const richTypes = { Date: true, RegExp: true, String: true, Number: true };
function diff(obj, newObj, options = { cyclesFix: true }, _stack = []) {
    const diffs = [];
    const isObjArray = Array.isArray(obj);
    for (const key in obj) {
        const objKey = obj[key];
        const path = isObjArray ? +key : key;
        if (!(key in newObj)) {
            diffs.push({
                t: 'r',
                p: [path],
                o: obj[key],
            });
            continue;
        }
        const newObjKey = newObj[key];
        const areObjects = typeof objKey === 'object' && typeof newObjKey === 'object';
        if (objKey &&
            newObjKey &&
            areObjects &&
            !richTypes[Object.getPrototypeOf(objKey)?.constructor?.name] &&
            (!options.cyclesFix || !_stack.includes(objKey))) {
            const nestedDiffs = diff(objKey, newObjKey, options, options.cyclesFix ? _stack.concat([objKey]) : []);
            diffs.push.apply(diffs, nestedDiffs.map((difference) => {
                difference.p.unshift(path);
                return difference;
            }));
        }
        else if (objKey !== newObjKey &&
            !(areObjects &&
                (Number.isNaN(objKey)
                    ? `${objKey}` === `${newObjKey}`
                    : +objKey === +newObjKey))) {
            diffs.push({
                p: [path],
                t: 'u',
                v: newObjKey,
                o: objKey,
            });
        }
    }
    const isNewObjArray = Array.isArray(newObj);
    for (const key in newObj) {
        if (!(key in obj)) {
            diffs.push({
                t: 'c',
                p: [isNewObjArray ? +key : key],
                v: newObj[key],
            });
        }
    }
    return diffs;
}
exports.diff = diff;
