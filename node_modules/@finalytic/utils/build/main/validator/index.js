"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.S = exports.SchemaFactory = exports.ObjectSchema = exports.ArraySchema = exports.NumericSchema = exports.StringSchema = exports.BaseSchema = exports.ValidationError = void 0;
const array_1 = __importDefault(require("./array"));
exports.ArraySchema = array_1.default;
const base_1 = __importDefault(require("./base"));
exports.BaseSchema = base_1.default;
const numeric_1 = __importDefault(require("./numeric"));
exports.NumericSchema = numeric_1.default;
const object_1 = __importDefault(require("./object"));
exports.ObjectSchema = object_1.default;
const string_1 = __importDefault(require("./string"));
exports.StringSchema = string_1.default;
var base_2 = require("./base");
Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function () { return base_2.ValidationError; } });
class SchemaFactory extends base_1.default {
    /**
     * Create an empty schema
     *
     * @exmaple { }
     *
     * @returns {BaseSchema<any>}
     */
    any() {
        return new base_1.default().copyWith(this);
    }
    /**
     * Create StringSchema
     *
     * @example { "type": "string" }
     *
     * @returns {StringSchema}
     */
    string() {
        return new string_1.default().copyWith(this);
    }
    /**
     * Create NumericSchema(number)
     *
     * @example { "type": "number" }
     *
     * @returns {NumericSchema}
     */
    number() {
        return new numeric_1.default('number').copyWith(this);
    }
    /**
     * Create NumericSchema(integer)
     *
     * @example { "type": "integer" }
     *
     * @returns {NumericSchema}
     */
    integer() {
        return new numeric_1.default('integer').copyWith(this);
    }
    /**
     * Create BooleanSchema
     *
     * @example { "type": "boolean" }
     *
     * @returns {BaseSchema<boolean>}
     */
    boolean() {
        return new base_1.default('boolean').copyWith(this);
    }
    /**
     * Create NullSchema
     *
     * @example { "type": "null" }
     *
     * @returns {BaseSchema<null>}
     */
    null() {
        return new base_1.default('null').copyWith(this);
    }
    /**
     * Create ArraySchema
     *
     * @example { "type": "array" }
     *
     * @returns {ArraySchema}
     */
    array() {
        return new array_1.default().copyWith(this);
    }
    /**
     * Create ArraySchema
     *
     * @example { "type": "array", "items": { ... } }
     *
     * @returns {ArraySchema}
     */
    list(items) {
        return new array_1.default().items(items).copyWith(this);
    }
    /**
     * Create ObjectSchema
     *
     * @example { "type": "object" }
     *
     * @returns {ObjectSchema}
     */
    object() {
        return new object_1.default().copyWith(this);
    }
    parse(plain) {
        const res = new object_1.default().copyWith({ plain: plain });
        return res;
    }
    /**
     * Create ObjectSchema
     *
     * @example { "type": "object", "properties": { ... }, "additionalProperties": false }
     *
     * @returns {ObjectSchema}
     */
    shape(props, additional = false) {
        let res = new object_1.default()
            .additionalProperties(additional)
            .copyWith(this);
        for (const prop in props)
            res = res.prop(prop, props[prop]);
        return res;
    }
    /**
     * Check the type of the provided value. Used custom ajv keyword.
     *
     * @param {Class} Type
     */
    instanceOf(Type) {
        return new base_1.default().custom((data) => data instanceof Type);
    }
}
exports.SchemaFactory = SchemaFactory;
exports.S = new SchemaFactory();
