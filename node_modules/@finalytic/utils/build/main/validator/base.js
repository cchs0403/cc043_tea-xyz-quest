"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationError = void 0;
const json_schema_1 = require("./json-schema");
class ValidationError extends Error {
    constructor(outputs) {
        super(outputs.map((e) => e.error).join(', '));
        this.outputs = outputs;
    }
}
exports.ValidationError = ValidationError;
class BaseSchema {
    constructor(type) {
        /*static ajv = new Ajv().addKeyword('custom', {
          validate: (
            value: string[],
            data: any,
            schema: Schema['plain'],
            path: string,
            full: any
          ) =>
            value.every((key) =>
              BaseSchema.validators[key](data, full, schema, path)
            ),
        });*/
        this.type = undefined;
        this.otype = undefined;
        this.plain = {};
        this.isRequired = true;
        this.isFluentSchema = true;
        this.$schema = 'http://json-schema.org/draft-07/schema#';
        this.definitions = undefined;
        if (type)
            this.plain.type = type;
    }
    /**
     * It defines a URI for the schema, and the base URI that other URI references within the schema are resolved against.
     *
     * @example { $id: "string" }
     *
     * @reference https://json-schema.org/latest/json-schema-core.html#id-keyword
     *
     * @param {string} $id - an #id
     * @returns {this}
     */
    id($id) {
        return this.copyWith({ plain: { $id } });
    }
    /**
     * The value must be a valid id e.g. #properties/foo
     *
     * @example { $ref: "string" }
     *
     * @param {string} ref
     * @returns {this}
     */
    ref($ref) {
        return this.copyWith({ plain: { $ref } });
    }
    /**
     * Set $schema property
     *
     * @example { $schema: "string" }
     *
     * @param {string} $schema
     */
    schema($schema) {
        return this.copyWith({ $schema });
    }
    /**
     * It can be used to decorate a user interface with information about the data produced by this user interface. A title will preferably be short.
     *
     * @example { title: "string" }
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.10.1
     *
     * @param {string} title
     * @returns {this}
     */
    title(title) {
        return this.copyWith({ plain: { title } });
    }
    /**
     * It can be used to decorate a user interface with information about the data
     * produced by this user interface. A description provides explanation about
     * the purpose of the instance described by the schema.
     *
     * @example { description: "string" }
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.10.1
     *
     * @param {string} description
     * @returns {this}
     */
    description(description) {
        return this.copyWith({ plain: { description } });
    }
    /**
     * The value of this keyword MUST be an array.
     * There are no restrictions placed on the values within the array.
     *
     * @example { examples: [ ... ] }
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.10.4
     *
     * @param {any[]} examples
     * @returns {this}
     */
    examples(...examples) {
        return this.copyWith({ plain: { examples } });
    }
    /**
     * There are no restrictions placed on the value of this keyword.
     *
     * @example { default: ... }
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.10.2
     *
     * @param {T} def
     * @returns {this}
     */
    default(def) {
        return this.copyWith({ plain: { default: def } });
    }
    /**
     * The "definitions" keywords provides a standardized location for schema authors to inline re-usable JSON Schemas into a more general schema.
     * There are no restrictions placed on the values within the array.
     *
     * @example { definitions: { [name]: definition } }
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.9
     *
     * @param {string} name
     * @param {BaseSchema} props
     * @returns {this}
     */
    definition(name, definition) {
        return this.copyWith({
            definitions: { ...this.definitions, [name]: definition.plain },
        });
    }
    /**
     * Because the differences between JSON Schemas and Open API (Swagger)
     * it can be handy to arbitrary modify the schema injecting a fragment
     *
     * * Examples:
     * - S.number().raw({ nullable:true })
     * - S.string().format('date').raw({ formatMaximum: '2020-01-01' })
     *
     * @example { somethingCustom: 'value' }
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.3.3
     *
     * @param {string} fragment an arbitrary JSON Schema to inject
     * @returns {this}
     */
    raw(fragment) {
        return this.copyWith({ plain: fragment });
    }
    /**
     * The value of this keyword MUST be an array. This array SHOULD have at least one element. Elements in the array SHOULD be unique.
     *
     * @example { enum: [ 'string' ] }
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1.2
     *
     * @param values
     * @returns {this}
     */
    enum(...values) {
        return this.copyWith({ plain: { enum: values } });
    }
    /**
     * The value of this keyword MAY be of any type, including null.
     *
     * @example { const: 'some' }
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.1.3
     *
     * @param value
     * @returns {this}
     */
    const(value) {
        return this.copyWith({ plain: { const: value } });
    }
    /**
     * It  MUST be a non-empty array. Each item of the array MUST be a valid JSON Schema.
     *
     * @example { anyOf: [ {} ] }
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.7.3
     *
     * @param {array} schemas
     * @returns {this}
     */
    anyOf(...schemas) {
        return this.copyWith({
            plain: { anyOf: schemas.map((schema) => schema.plain) },
        });
    }
    /**
     * It MUST be a non-empty array. Each item of the array MUST be a valid JSON Schema.
     *
     * @example { allOf: [ {} ] }
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.7.1
     *
     * @param {array} schemas
     * @returns {this}
     */
    allOf(...schemas) {
        return this.copyWith({
            plain: { allOf: schemas.map((schema) => schema.plain) },
        });
    }
    /**
     * It MUST be a non-empty array. Each item of the array MUST be a valid JSON Schema.
     *
     * @example { oneOf: [ {} ] }
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.7.2
     *
     * @param {array} schemas
     * @returns {this}
     */
    oneOf(...schemas) {
        return this.copyWith({
            plain: { oneOf: schemas.map((schema) => schema.plain) },
        });
    }
    /**
     * It MUST be a valid JSON Schema.
     *
     * @example { not: {} }
     *
     * @param {BaseSchema} not
     * @returns {this}
     */
    not(not) {
        return this.copyWith({ plain: { not: not.plain } });
    }
    /**
     * Should be used only with ObjectSchema. By default all properties in Object Schema are required. This will make them optional
     */
    optional() {
        return this.copyWith({ isRequired: false });
    }
    /**
     * This validation outcome of this keyword's subschema has no direct effect on the overall validation result.
     * Rather, it controls which of the "then" or "else" keywords are evaluated.
     * When "if" is present, and the instance successfully validates against its subschema, then
     * validation succeeds against this keyword if the instance also successfully validates against this keyword's subschema.
     *
     * @param {BaseSchema} ifClause
     * @param {BaseSchema} thenClause
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.6.1
     * @returns {this}
     */
    ifThen(ifClause, thenClause) {
        return this.copyWith({
            // biome-ignore lint/suspicious/noThenProperty: <explanation>
            plain: { if: ifClause.plain, then: thenClause.plain },
        });
    }
    /**
     * When "if" is present, and the instance fails to validate against its subschema,
     * then validation succeeds against this keyword if the instance successfully validates against this keyword's subschema.
     *
     * @param {BaseSchema} ifClause
     * @param {BaseSchema} thenClause
     * @param {BaseSchema} elseClause
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.6.1
     * @returns {this}
     */
    ifThenElse(ifClause, thenClause, elseClause) {
        return this.copyWith({
            plain: {
                if: ifClause.plain,
                // biome-ignore lint/suspicious/noThenProperty: <explanation>
                then: thenClause.plain,
                else: elseClause.plain,
            },
        });
    }
    /**
     * Add custom validation functions.
     * Since custom validators didn't supported by JSON Schema, I used AJV custom keywords to add such functionality
     *
     * @param funcs - validators
     *
     * @returns {this}
     */
    custom(...validators) {
        const keys = validators.map((validator) => {
            const hash = Math.random().toString(36).substring(2, 15) +
                Math.random().toString(36).substring(2, 15);
            BaseSchema.validators[hash] = validator;
            return hash;
        });
        return this.copyWith({
            plain: { custom: [...(this.plain.custom || []), ...keys] },
        });
    }
    /**
     * Validate provided data with current schema using ajv, does not throw errors
     *
     * @param {T} data
     */
    validate(data) {
        const validator = new json_schema_1.Validator(this.valueOf());
        const { valid, errors } = validator.validate(data);
        return [valid, errors];
    }
    /**
     * Validate provided data with current schema using ajv, if validation failed function will throw error
     *
     * @param {T} data
     */
    ensure(data) {
        const [valid, errors] = this.validate(data);
        if (!valid)
            throw new ValidationError(errors);
        return data;
    }
    /**
     * Make copy of current schema with modified values
     *
     * @param modifyObject
     */
    copyWith(modifyObject) {
        return Object.assign(Object.create(this.constructor.prototype), {
            ...this,
            ...modifyObject,
            plain: { ...this.plain, ...modifyObject.plain },
        });
    }
    /**
     * It returns all the schema values
     *
     * @returns {S}
     */
    valueOf() {
        return {
            ...this.plain,
            ...(this.$schema && { $schema: this.$schema }),
            ...(this.definitions && { definitions: this.definitions }),
        };
    }
}
BaseSchema.validators = {};
exports.default = BaseSchema;
