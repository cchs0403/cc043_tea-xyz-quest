export const expression = {
    toString(value, separator = ' ') {
        return value
            .map((expr) => {
            switch (expr.kind) {
                case 'number':
                    return expr.value;
                case 'operator':
                    return expr.type;
                case 'field':
                    return `"${expr.value}"`;
                case 'func':
                    return `${expr.type}(${this.toString(expr.value, ', ')})`;
                case 'group':
                    return `(${this.toString(expr.value, ' ')})`;
                default:
                    return '';
            }
        })
            .join(separator);
    },
    toTree(value) {
        function parseValue(expression, initialPosition = 0, parentNode) {
            let position = initialPosition;
            let skip = false;
            const tree = [];
            // Regex
            const numRegex = /[0-9.]/;
            const letterRegex = /[a-zA-Z]/;
            const operatorRegex = new RegExp(`[${Object.keys(defaultOperations)
                .map((c) => `\\${c}`)
                .join('')}]`);
            const checkPreviousNode = (previousNode, allowedTypes) => {
                if (previousNode && !allowedTypes.includes(previousNode.kind)) {
                    throw new Error(`Incorrect previous node of type ${previousNode.kind}.`);
                }
            };
            const arr = expression.split('');
            for (let i = 0; i < arr.length; i++) {
                const previousNode = tree.at(-1);
                const char = arr[i];
                if (i < position || skip) {
                    continue;
                }
                // Accounts
                if (char === '"') {
                    checkPreviousNode(previousNode, ['func', 'group', 'operator']);
                    let temp = '';
                    let nextPos = 1;
                    while (!/["]/.test(arr[i + nextPos])) {
                        temp = `${temp}${arr[i + nextPos]}`;
                        nextPos++;
                    }
                    const node = {
                        kind: 'field',
                        //type: temp,
                        value: temp,
                    };
                    tree.push(node);
                    position = i + nextPos + 1;
                    continue;
                }
                // Numbers
                if (numRegex.test(char)) {
                    checkPreviousNode(previousNode, parentNode?.kind === 'func'
                        ? ['operator', 'number', 'field', 'group', 'func']
                        : ['operator']);
                    let temp = char;
                    let nextPos = 1;
                    while (numRegex.test(arr[i + nextPos])) {
                        temp = `${temp}${arr[i + nextPos]}`;
                        nextPos++;
                    }
                    const node = {
                        kind: 'number',
                        value: Number.parseFloat(temp),
                    };
                    tree.push(node);
                    position = i + nextPos;
                    continue;
                }
                // Operators
                if (operatorRegex.test(char)) {
                    checkPreviousNode(previousNode, [
                        'func',
                        'group',
                        'field',
                        'number',
                        'operator',
                    ]);
                    if (previousNode?.kind === 'operator' &&
                        ['*', '/', '%'].includes(char)) {
                        throw new Error('Incorrect operator chain');
                    }
                    const node = { kind: 'operator', type: char };
                    tree.push(node);
                    continue;
                }
                // Paranthesis
                if (char === '(') {
                    checkPreviousNode(previousNode, ['operator']);
                    // returns tree and position to continue from
                    const { tree: childTree, returnPosition } = parseValue(expression, i + 1, { kind: 'group', value: [], type: 'parenthesis' });
                    const node = {
                        kind: 'group',
                        type: 'parenthesis',
                        value: childTree,
                    };
                    tree.push(node);
                    position = returnPosition;
                    continue;
                }
                // Functions
                if (letterRegex.test(char)) {
                    checkPreviousNode(previousNode, ['operator']);
                    let temp = char;
                    let nextPos = 1;
                    while (arr[i + nextPos] && letterRegex.test(arr[i + nextPos])) {
                        temp = `${temp}${arr[i + nextPos]}`;
                        nextPos++;
                    }
                    const func = temp.toLowerCase();
                    if (!defaultFunctions[func]) {
                        throw Error(`Function '${temp}' does not exist.`);
                    }
                    const { tree: childTree, returnPosition } = parseValue(expression, i + nextPos + 1, { kind: 'func', value: [], type: func });
                    const node = {
                        kind: 'func',
                        type: func,
                        value: childTree,
                    };
                    tree.push(node);
                    position = returnPosition;
                    continue;
                }
                // Skip from now and return try and position up to here
                if (char === ')') {
                    skip = true;
                    position = i + 1;
                }
            }
            return { tree, returnPosition: position };
        }
        const { tree } = parseValue(value);
        return tree;
    },
    execute(value, context = {}) {
        const explain = context?.explain ? [] : undefined;
        const functions = {
            ...defaultFunctions,
            ...(context.functions || {}),
        };
        const getData = context.getData || (() => undefined);
        function evaluate(node, level) {
            if (node.kind === 'group' || node.kind === 'func')
                return evaluateTree(node.value, node, level + 1);
            if (node.kind === 'field') {
                const data = getData(node.value);
                if (data === undefined)
                    throw new Error(`No data for ${node.value}`);
                return data;
            }
            if (node.kind === 'number')
                return node.value;
            throw new Error(`Invalid expression ${node.type} ${node.kind}`);
        }
        function evaluateTree(t, parentNode, level = 0) {
            if (explain)
                explain.push(`Eval: ${t.map((x) => `[${Object.values(x)}]`).join(', ')}`);
            if (level > 10)
                throw new Error(`Max recursion depth reached (${level})`);
            let sum = 0;
            const tree = [...t];
            for (let i = 0; i < tree.length; i++) {
                const node = tree[i];
                const previousNode = i > 0 ? tree[i - 1] : undefined;
                if (explain) {
                    const part = previousNode
                        ? `prev [${Object.values(previousNode)}], `
                        : '';
                    explain.push(`${new Array(level).join(' ')}${part}current [${Object.values(node)}], sum ${sum}`);
                }
                // Hack for multiplication and division
                {
                    const nextNode = tree[i + 1];
                    // if current node is '-' and previous node is '*' or '/'
                    // e.g. 1 * - 1 => 1 * 1 * -1
                    if (node?.kind === 'operator' && previousNode?.kind === 'operator') {
                        // disallow 1 + * 1
                        // disallow 1 * * 1
                        if ((isBasic(previousNode) && isMultiply(node)) ||
                            (isMultiply(previousNode) && isMultiply(node)))
                            throw new Error(`Incorrect operator chain ${previousNode.type}, ${node.type}`);
                        if (isMultiply(previousNode) && isBasic(node)) {
                            // Find next non-operator index
                            const nextOperandIndex = tree.findIndex((x, index) => x.kind !== 'operator' && index > i) + 1;
                            // Cut all elements between i and nextOperandIndex and insert them into a group
                            const [_, ...elements] = tree.splice(i, nextOperandIndex);
                            elements.push({ kind: 'operator', type: '*' }, { kind: 'number', value: -1 });
                            tree.splice(i, 0, {
                                kind: 'group',
                                type: 'parenthesis',
                                value: elements,
                            });
                            i = i - 1;
                            continue;
                        }
                    }
                    // if next node is an operator and the parent is not a group, simulate a parenthesis
                    // e.g. 1 * 1 + 2 => (1 * 1) + 2
                    if (nextNode?.kind === 'operator' &&
                        parentNode?.kind !== 'group' &&
                        isMultiplyMod(nextNode)) {
                        // Find next non-operator index
                        const nextOperandIndex = tree.findIndex((x, index) => x.kind !== 'operator' && index > i) +
                            1;
                        // Cut all elements between i and nextOperandIndex and insert them into a group
                        const elements = tree.splice(i, nextOperandIndex);
                        tree.splice(i, 0, {
                            kind: 'group',
                            type: 'parenthesis',
                            value: elements,
                        });
                        i = i - 1;
                        continue;
                    }
                }
                // Skip operators, they are handled by setting previousNode
                if (node.kind !== 'operator') {
                    if (!previousNode) {
                        // No previous node, we can simply eval the current node
                        sum = evaluate(node, level);
                    }
                    else {
                        // Previous node found, need to perform an operation
                        let fn;
                        const current = evaluate(node, level);
                        if (previousNode.kind === 'operator') {
                            fn = defaultOperations[previousNode.type];
                        }
                        else if (parentNode && parentNode.kind === 'func') {
                            // Allow upper vs lower, e.g. SUM vs sum
                            fn =
                                functions[parentNode.type.toLowerCase()] ||
                                    functions[parentNode.type.toUpperCase()];
                            if (!fn) {
                                throw new Error(`No function called ${parentNode.value} found`);
                            }
                        }
                        if (!fn) {
                            throw new Error(`No operator or function found for node ${node.kind}/${node.value}`);
                        }
                        sum = fn(sum, current);
                    }
                }
            }
            return sum;
        }
        const res = evaluateTree(value);
        if (explain)
            console.log(explain);
        return res;
    },
    async executeAsync(value, context = {}) {
        const functions = {
            ...defaultFunctions,
            ...(context.functions || {}),
        };
        const getData = context.getData || (() => undefined);
        async function evaluateAsync(node, level) {
            if (node.kind === 'group' || node.kind === 'func')
                return await evaluateTreeAsync(node.value, node, level + 1);
            if (node.kind === 'field') {
                const data = await getData(node.value);
                if (data === undefined)
                    throw new Error(`No data for ${node.value}`);
                return data;
            }
            if (node.kind === 'number')
                return node.value;
            throw new Error(`Invalid expression ${node.type} ${node.kind}`);
        }
        async function evaluateTreeAsync(t, parentNode, level = 0) {
            if (level > 10)
                throw new Error(`Max recursion depth reached (${level})`);
            let sum = 0;
            const tree = [...t];
            for (let i = 0; i < tree.length; i++) {
                const node = tree[i];
                const previousNode = i > 0 ? tree[i - 1] : undefined;
                // Hack for multiplication and division
                {
                    const nextNode = tree[i + 1];
                    // if next node is an operator and the parent is not a group
                    if (nextNode?.kind === 'operator' &&
                        parentNode?.kind !== 'group' &&
                        isMultiplyMod(nextNode)) {
                        // Remove this and next 2 nodes
                        tree.splice(i, 3, {
                            kind: 'group',
                            type: 'parenthesis',
                            value: [node, nextNode, tree[i + 2]],
                        });
                        i = i - 1;
                        continue;
                    }
                }
                // Skip operators, they are handled by setting previousNode
                if (node.kind !== 'operator') {
                    if (!previousNode) {
                        // No previous node, we can simply eval the current node
                        sum = await evaluateAsync(node, level);
                    }
                    else {
                        // Previous node found, need to perform an operation
                        let fn;
                        const current = await evaluateAsync(node, level);
                        if (previousNode.kind === 'operator') {
                            fn = defaultOperations[previousNode.type];
                        }
                        else if (parentNode && parentNode.kind === 'func') {
                            // Allow upper vs lower, e.g. SUM vs sum
                            fn =
                                functions[parentNode.type.toLowerCase()] ||
                                    functions[parentNode.type.toUpperCase()];
                            if (!fn) {
                                throw new Error(`No function called ${parentNode.value} found`);
                            }
                        }
                        if (!fn) {
                            throw new Error(`No operator or function found for node ${node.kind}/${node.value}`);
                        }
                        sum = fn(sum, current);
                    }
                }
            }
            return sum;
        }
        return await evaluateTreeAsync(value);
    },
};
const basicOperations = {
    '+': (a, b) => a + b,
    '-': (a, b) => a - b,
};
const multiplicationOperations = {
    '/': (a, b) => a / b,
    '*': (a, b) => a * b,
};
const nonBasicOperations = {
    '%': (a, b) => (a / 100) * b,
};
const defaultOperations = {
    ...basicOperations,
    ...multiplicationOperations,
    ...nonBasicOperations,
};
function isMultiplyMod(node) {
    return (node.kind === 'operator' &&
        (node.type === '*' || node.type === '/' || node.type === '%'));
}
function isMultiply(node) {
    return node.kind === 'operator' && (node.type === '*' || node.type === '/');
}
function isBasic(node) {
    return node.kind === 'operator' && (node.type === '+' || node.type === '-');
}
const defaultFunctions = {
    sum: (a, b) => a + b,
};
