import { ms } from './time';
export class RateLimitAbortError extends Error {
    constructor() {
        super('Throttled function aborted');
        this.name = 'AbortError';
    }
}
export function rateLimit({ limit, interval: i }) {
    if (!limit || !i) {
        return (fn) => {
            return (...args) => fn(...args);
        };
    }
    const interval = typeof i === 'string' ? ms(i) : i;
    if (!Number.isFinite(limit)) {
        throw new TypeError('Expected `limit` to be a finite number');
    }
    if (!Number.isFinite(interval)) {
        throw new TypeError('Expected `interval` to be a finite number');
    }
    const queue = new Map();
    let currentTick = 0;
    let activeCount = 0;
    function windowedDelay() {
        const now = Date.now();
        if (now - currentTick > interval) {
            activeCount = 1;
            currentTick = now;
            return 0;
        }
        if (activeCount < (limit || 0)) {
            activeCount++;
        }
        else {
            currentTick += interval;
            activeCount = 1;
        }
        return currentTick - now;
    }
    return (fn) => {
        const throttled = (...args) => {
            if (!throttled.isEnabled) {
                return (async () => fn(...args))();
            }
            let timeout;
            return new Promise((resolve, reject) => {
                const execute = () => {
                    resolve(fn(...args));
                    queue.delete(timeout);
                };
                timeout = setTimeout(execute, windowedDelay());
                queue.set(timeout, reject);
            });
        };
        throttled.abort = () => {
            for (const timeout of queue.keys()) {
                clearTimeout(timeout);
                queue.get(timeout)(new RateLimitAbortError());
            }
            queue.clear();
        };
        throttled.isEnabled = true;
        return throttled;
    };
}
