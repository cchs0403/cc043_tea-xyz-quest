import BaseSchema from './base';
export default class ObjectSchema extends BaseSchema {
    constructor() {
        super('object');
    }
    /**
     * The value of "properties" MUST be an object. Each value of this object MUST be a valid JSON Schema
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.5.4
     *
     * @param {string} name
     * @param {ObjectSchema} schema
     * @returns {ObjectSchema}
     */
    prop(name, schema) {
        return this.copyWith({
            plain: {
                properties: { ...this.plain.properties, [name]: schema.plain },
                ...(schema.isRequired && {
                    required: [...(this.plain.required || []), name],
                }),
            },
        });
    }
    /**
     * This keyword determines how child instances validate for objects, and does not directly validate the immediate instance itself.
     * Validation with "additionalProperties" applies only to the child values of instance names that do not match any names in "properties",
     * and do not match any regular expression in "patternProperties".
     * For all such properties, validation succeeds if the child instance validates against the "additionalProperties" schema.
     * Omitting this keyword has the same behavior as an empty schema.
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.5.6
     *
     * @param {BaseSchema|boolean} value
     * @returns {ObjectSchema}
     */
    additionalProperties(schema) {
        return this.copyWith({
            plain: {
                additionalProperties: typeof schema === 'boolean' ? schema : schema.plain,
            },
        });
    }
    /**
     * If the instance is an object, this keyword validates if every property name in the instance validates against the provided schema.
     * Note the property name that the schema is testing will always be a string.
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.5.7
     *
     * @param {StringSchema} nameSchema
     * @returns {ObjectSchema}
     */
    propertyNames(nameSchema) {
        return this.copyWith({ plain: { propertyNames: nameSchema.plain } });
    }
    /**
     * An object instance is valid against "minProperties" if its number of properties is greater than, or equal to, the value of this keyword.
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.5.2
     *
     * @param {number} minProperties
     * @returns {ObjectSchema}
     */
    minProperties(minProperties) {
        return this.copyWith({ plain: { minProperties } });
    }
    /**
     * An object instance is valid against "maxProperties" if its number of properties is less than, or equal to, the value of this keyword.
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.5.1
     *
     * @param {number} maxProperties
     * @returns {ObjectSchema}
     */
    maxProperties(maxProperties) {
        return this.copyWith({ plain: { maxProperties } });
    }
    /**
     * This keyword specifies rules that are evaluated if the instance is an object and contains a certain property.
     * This keyword's value MUST be an object. Each property specifies a dependency. Each dependency value MUST be an array or a valid JSON Schema.
     * If the dependency value is a subschema, and the dependency key is a property in the instance, the entire instance must validate against the dependency value.
     * If the dependency value is an array, each element in the array, if any, MUST be a string, and MUST be unique. If the dependency key is a property in the instance, each of the items in the dependency value must be a property that exists in the instance.
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.5.7
     *
     * @param {Record<string, string[] | BaseSchema>} deps
     * @returns {ObjectSchema}
     */
    dependencies(deps) {
        const dependencies = {};
        for (const dep in deps) {
            dependencies[dep] = Array.isArray(deps[dep])
                ? deps[dep]
                : deps[dep].plain;
        }
        return this.copyWith({ plain: { dependencies } });
    }
    /**
     * Each property name of this object SHOULD be a valid regular expression, according to the ECMA 262 regular expression dialect.
     * Each property value of this object MUST be a valid JSON Schema.
     * This keyword determines how child instances validate for objects, and does not directly validate the immediate instance itself.
     * Validation of the primitive instance type against this keyword always succeeds.
     * Validation succeeds if, for each instance name that matches any regular expressions that appear as a property name in this keyword's value, the child instance for that name successfully validates against each schema that corresponds to a matching regular expression.
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.5.5
     *
     * @param {Record<string, BaseSchema>} props
     * @returns {ObjectSchema}
     */
    patternProperties(props) {
        const patternProperties = {};
        for (const prop in props)
            patternProperties[prop] = props[prop].plain;
        return this.copyWith({ plain: { patternProperties } });
    }
    /**
     * Set required array
     *
     * @reference https://json-schema.org/latest/json-schema-validation.html#rfc.section.6.5.3
     *
     * @returns {ObjectSchema}
     */
    required(...fields) {
        return this.copyWith({ plain: { required: fields } });
    }
    /**
     * Make schema optional in {ObjectSchema}
     *
     * @returns {ObjectSchema}
     */
    optional() {
        return this.copyWith({ isRequired: false });
    }
    /**
     * Return new ObjectSchema with removed required fields (recursively)
     *
     * @returns {ObjectSchema}
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    // biome-ignore lint/complexity/noBannedTypes: <explanation>
    partial() {
        const plain = (function partial(schema) {
            for (const key in schema.properties || {}) {
                if (schema.properties[key].type === 'object') {
                    schema = {
                        ...schema,
                        properties: {
                            ...schema.properties,
                            [key]: partial({ ...schema.properties[key] }),
                        },
                    };
                }
            }
            const { required: _, ...partialSchema } = schema; // eslint-disable-line @typescript-eslint/no-unused-vars
            return partialSchema;
        })(this.valueOf());
        return Object.assign(Object.create(this.constructor.prototype), {
            ...this,
            plain,
        });
    }
}
