import type { O } from 'ts-toolbelt';
import ArraySchema from './array';
import BaseSchema from './base';
import type { Schema as JSchema } from './json-schema';
import NumericSchema from './numeric';
import ObjectSchema from './object';
import StringSchema from './string';
export { ValidationError, type BaseJsonSchema } from './base';
export type { ObjectJsonSchema } from './object';
export type Class<T = any> = {
    new (): T;
    prototype: T;
};
export type Optional<T extends object> = O.Optional<T, O.SelectKeys<T, undefined>>;
export type Shape<T extends ShapeInput> = Optional<{
    [K in keyof T]: T[K]['otype'];
}>;
export type ShapeInput = Record<string, BaseSchema<any, boolean>>;
export type Schema = BaseSchema | StringSchema | NumericSchema | ArraySchema | ObjectSchema;
export { BaseSchema, StringSchema, NumericSchema, ArraySchema, ObjectSchema };
export declare class SchemaFactory extends BaseSchema {
    /**
     * Create an empty schema
     *
     * @exmaple { }
     *
     * @returns {BaseSchema<any>}
     */
    any(): BaseSchema<import("./base").Any, true, Readonly<import("./base").BaseJsonSchema>>;
    /**
     * Create StringSchema
     *
     * @example { "type": "string" }
     *
     * @returns {StringSchema}
     */
    string(): StringSchema<string, true>;
    /**
     * Create NumericSchema(number)
     *
     * @example { "type": "number" }
     *
     * @returns {NumericSchema}
     */
    number(): NumericSchema<number, true>;
    /**
     * Create NumericSchema(integer)
     *
     * @example { "type": "integer" }
     *
     * @returns {NumericSchema}
     */
    integer(): NumericSchema<number, true>;
    /**
     * Create BooleanSchema
     *
     * @example { "type": "boolean" }
     *
     * @returns {BaseSchema<boolean>}
     */
    boolean(): BaseSchema<boolean, true, Readonly<import("./base").BaseJsonSchema>>;
    /**
     * Create NullSchema
     *
     * @example { "type": "null" }
     *
     * @returns {BaseSchema<null>}
     */
    null(): BaseSchema<null, true, Readonly<import("./base").BaseJsonSchema>>;
    /**
     * Create ArraySchema
     *
     * @example { "type": "array" }
     *
     * @returns {ArraySchema}
     */
    array(): ArraySchema<any, true>;
    /**
     * Create ArraySchema
     *
     * @example { "type": "array", "items": { ... } }
     *
     * @returns {ArraySchema}
     */
    list<T extends BaseSchema>(items: T): ArraySchema<T["type"], true>;
    /**
     * Create ObjectSchema
     *
     * @example { "type": "object" }
     *
     * @returns {ObjectSchema}
     */
    object(): ObjectSchema<{}, true>;
    parse<T extends Record<string, any>>(plain: JSchema): ObjectSchema<T, true>;
    /**
     * Create ObjectSchema
     *
     * @example { "type": "object", "properties": { ... }, "additionalProperties": false }
     *
     * @returns {ObjectSchema}
     */
    shape<T extends Record<string, BaseSchema<any, boolean>>>(props: T, additional?: boolean): ObjectSchema<Optional<{ [K in keyof T]: T[K]["otype"]; }>, true>;
    /**
     * Check the type of the provided value. Used custom ajv keyword.
     *
     * @param {Class} Type
     */
    instanceOf<P extends Class>(Type: P): BaseSchema<InstanceType<P>, true, Readonly<import("./base").BaseJsonSchema>>;
}
export declare const S: SchemaFactory;
