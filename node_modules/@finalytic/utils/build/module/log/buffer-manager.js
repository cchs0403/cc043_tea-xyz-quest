import { ensure } from '../utils';
import { DEFAULT_INGESTION_URL, FLUSH_BYTE_LIMIT, LOG_LINE_FLUSH_TIMEOUT, MAX_BACK_OFF, MAX_FETCH_ERROR_RETRY, SAMPLE_RATE, STARTING_BACK_OFF, } from './constants';
import utils from './utils';
const isUnderByteLimit = (buffer) => utils.jsonByteSize(buffer) < FLUSH_BYTE_LIMIT;
const defaultOptions = ensure({
    url: DEFAULT_INGESTION_URL,
    hostname: 'function',
    flushInterval: LOG_LINE_FLUSH_TIMEOUT,
    enableStacktrace: true,
    sampleRate: SAMPLE_RATE,
    tags: [],
    app: '',
    type: 'pretty',
});
let defaultOptionsOverwrite = undefined;
export function setDefaultLogOptions(options) {
    defaultOptionsOverwrite = options;
}
export class Log {
    context;
    _log;
    constructor(context, _log) {
        this.context = context;
        this._log = _log;
    }
    getContext = () => this.context;
    replaceContext = (newContext) => {
        this.context = { ...newContext };
    };
    addContext = (newContext) => {
        this.context = { ...this.context, ...newContext };
    };
    child = (newContext) => {
        return new Log({ ...this.context, ...newContext }, this.log);
    };
    error = (message, context = {}) => {
        this._log(message, { ...this.context, ...context }, 'error');
    };
    warn = (message, context = {}) => {
        this._log(message, { ...this.context, ...context }, 'warn');
    };
    debug = (message, context = {}) => {
        this._log(message, { ...this.context, ...context }, 'debug');
    };
    info = (message, context = {}) => {
        this._log(message, { ...this.context, ...context }, 'info');
    };
    log = (message, context = {}) => {
        this._log(message, { ...this.context, ...context }, 'log');
    };
}
export class Logger extends Log {
    options;
    buffer = [];
    retryCount = 0;
    backOffInterval = 0;
    loggerError = false;
    timer;
    getOptions = () => ({
        ...defaultOptions,
        ...defaultOptionsOverwrite,
        ...this.options,
    });
    constructor(options = {}, initialContext) {
        const context = initialContext || options.defaultContext || {};
        super(context, (message, context, level = 'log') => {
            if (`${message}`.includes('Warning: Setting the NODE_TLS_REJECT_UNAUTHORIZED'))
                return;
            if (`${message}`.includes('ExperimentalWarning: The Fetch API is an experimental feature.'))
                return;
            this.captureMessage({
                level,
                message,
                context,
            });
        });
        this.options = options;
    }
    lastTime = Date.now();
    captureMessage = ({ level = 'log', message, context = {} }) => {
        if (message instanceof Error) {
            this.captureError(message, context);
            return;
        }
        this.generateLogLine({ level, message, context });
    };
    captureError = (error, context, isUnhandledRejection = false) => {
        let message = error.name
            ? `${error.name}: ${error.message}`
            : error.message;
        if (isUnhandledRejection) {
            message = `Uncaught (in promise) ${message}`;
        }
        this.generateLogLine({
            level: 'error',
            message,
            error: {
                colno: error.columnNumber || error.colno || error.colNo,
                lineno: error.lineNumber || error.lineno || error.lineNo,
                stacktrace: error.stack || error.stacktrace,
                source: error.fileName || error.source,
            },
            context,
            disableStacktrace: !!(error.stack || error.stacktrace), // Don't generate a second stacktrace for errors since they already have it
        });
    };
    generateLogLine = ({ level = 'log', message, context, error = null, disableStacktrace = false, }) => {
        const opts = this.getOptions();
        if (opts.type === 'off')
            return;
        if (opts.type === 'pretty') {
            const lastTime = this.lastTime;
            this.lastTime = Date.now();
            const error = message;
            utils.originalConsole[level](...[
                `[${this.getOptions().hostname}/${this.getOptions().app}] [${new Date().toISOString()} +${this.lastTime - lastTime}ms]`,
                message instanceof Error
                    ? {
                        message,
                        colno: error.columnNumber || error.colno || error.colNo,
                        lineno: error.lineNumber || error.lineno || error.lineNo,
                        stacktrace: error.stack || error.stacktrace,
                        source: error.fileName || error.source,
                    }
                    : message,
                // context,
            ]
                .filter((i) => i !== undefined)
                .map((x) => typeof x === 'object' ? utils.stringify(x, null, 2) : x));
        }
        else {
            // run the beforeSend hooks
            const data = (opts.hooks || { beforeSend: [] }).beforeSend.reduce((acc, fn) => (acc == null ? null : fn(acc)), {
                level,
                message,
                context,
            });
            // beforeSend stopped the log
            if (data == null) {
                return;
            }
            const logMessage = typeof data.message === 'string'
                ? data.message
                : utils.stringify(data.message);
            const line = {
                timestamp: Math.floor(Date.now() / 1000),
                app: opts.app,
                level: data.level,
                meta: context || {},
            };
            if (error)
                line.meta.error = error;
            // if (context && Object.keys(context).length) line.meta.context = context;
            if (!disableStacktrace && opts.enableStacktrace)
                line.meta.stacktrace = utils.getStackTrace();
            if (opts.type === 'stdout')
                utils.originalConsole.log(JSON.stringify({ message: logMessage, ...line }));
            else
                this.process({ line: logMessage, ...line });
        }
    };
    timeout = () => {
        if (this.retryCount > 0) {
            this.backOffInterval = utils.backOffWithJitter(STARTING_BACK_OFF, MAX_BACK_OFF, this.backOffInterval || STARTING_BACK_OFF);
            return this.backOffInterval;
        }
        return LOG_LINE_FLUSH_TIMEOUT;
    };
    splitAndFlush = async (logLines) => {
        const lines = [...logLines];
        const half = Math.floor(lines.length / 2);
        const lines2 = lines.splice(half);
        this.flush(lines);
        this.flush(lines2);
    };
    flush = async (lines) => {
        if (!lines) {
            lines = [...this.buffer];
            this.buffer = [];
        }
        if (!lines.length)
            return;
        if (isUnderByteLimit(lines)) {
            await this.send(lines);
        }
        else if (lines.length === 1) {
            internalErrorLogger(`LogDNA Browser Logger was unable to send the previous log lines because the log size was greater than ${FLUSH_BYTE_LIMIT} bytes`);
        }
        else {
            await this.splitAndFlush(lines);
        }
    };
    process = async (lines) => {
        if (Array.isArray(lines)) {
            this.buffer = this.buffer.concat(lines);
        }
        else {
            this.buffer.push(lines);
        }
        if (this.timer) {
            clearTimeout(this.timer);
        }
        if (!isUnderByteLimit(this.buffer)) {
            return await this.flush();
        }
        this.timer = setTimeout(async () => {
            await this.flush();
            this.timer = undefined;
        }, this.timeout());
    };
    send = async (lines) => {
        const opts = this.getOptions();
        if (this.loggerError) {
            return;
        }
        const params = [
            ['hostname', opts.hostname],
            ['now', `${Date.now()}`],
        ];
        if (opts.tags?.length)
            params.push(['tags', opts.tags]);
        const ingestUrlParams = new URLSearchParams(params);
        const ingestUrl = `${opts.url}?${ingestUrlParams}`;
        const errorMsg = 'Unable to send previous logs batch to LogDNA';
        try {
            const response = await fetch(ingestUrl, {
                method: 'POST',
                //keepalive: true,
                headers: {
                    Authorization: `Basic ${btoa(`${opts.ingestionKey}:`)}`,
                    'Content-Type': 'application/json',
                    Accept: 'application/json',
                },
                body: utils.stringify({ lines }),
            });
            if (response.ok) {
                this.retryCount = 0;
                this.backOffInterval = 0;
            }
            else {
                if (response.status >= 400 && response.status < 500) {
                    internalErrorLogger(`${errorMsg}: ${response.statusText}`);
                }
                else if (response.status >= 500) {
                    this.retryCount = this.retryCount + 1;
                    if (this.retryCount > MAX_FETCH_ERROR_RETRY) {
                        internalErrorLogger(`${errorMsg}: ${response.statusText}`);
                    }
                    else {
                        await this.process(lines);
                    }
                }
            }
        }
        catch (error) {
            // If we have any issues sending logs shut down the service immediately
            // This is to avoid ending up in a circular loop of error logs and causing app
            // performance issues or ddos-ing out api.
            this.loggerError = true;
            internalErrorLogger(`LogDNA Browser Logger is unable to send logs to LogDNA.
        Possible issues:
         - Ingestion key is incorrect
         - The configured LogDNA ingestion url is incorrect
         - LogDNA ingestion endpoint is down. https://status.logdna.com/

         Error: ${error.message}
        `);
        }
    };
}
const internalErrorLogger = (message) => {
    console.error(message);
};
