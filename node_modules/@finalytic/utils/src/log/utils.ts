import safeStringify from 'fast-safe-stringify';
import { DEFAULT_TAG, HOSTNAME_CHECK } from './constants';

import type { Tags } from './types';

const validateHostname = (hostname: string) => HOSTNAME_CHECK.test(hostname);

const parseTags = (tags: Tags = []) => {
  if (
    (typeof tags !== 'string' && !Array.isArray(tags)) ||
    (Array.isArray(tags) && tags.some((tag) => typeof tag !== 'string'))
  ) {
    throw new Error(
      'LogDNA Browser Logger `tags` must be a string or an array of strings'
    );
  }

  if (typeof tags === 'string') {
    tags = [tags];
  }

  return [DEFAULT_TAG, ...tags].filter((tag) => tag !== '').join(',');
};

const stringify = (...args: Parameters<typeof safeStringify>) =>
  safeStringify(...args);

const getStackTrace = () => {
  const stack = new Error().stack || '';
  const array = stack
    .split('\n')
    .map((line) => line.trim().substring(3))
    .filter(
      (line, i) =>
        i !== 0 &&
        !line.startsWith('Logger2.') &&
        !line.startsWith('console.') &&
        !line.startsWith('Logger.') &&
        !line.startsWith('Log.') &&
        !line.includes('@finalytic/function') &&
        !line.startsWith('Object.getStackTrace')
    );
  return array.join('\n');
};

const _randomBetween = (min: number, max: number) => {
  return Math.floor(Math.random() * (max - min + 1)) + min;
};
/**
 * This implements exponential backoff with "decorrelated jitter" for use in
 * failing HTTP calls and their retries.  Although the HTTP calls shouldn't be in
 * contention with other clients, the jitter will help alleviate a flood
 * of connections to the server in the event LogDNA suddenly comes back
 * online after being unavailable.
 *
 * @see https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/
 *
 * @param   {Number} base The base sleep time to be used
 * @param   {Number} cap The maximum sleep time allowable in milliseconds
 * @param   {Number} lastSleep The last (or starting) sleep time used
 * @returns {Number} calculated sleep time
 */
const backOffWithJitter = (base: number, cap: number, lastSleep: number) =>
  Math.min(cap, _randomBetween(base, lastSleep * 3));

const jsonByteSize = (obj: unknown) => {
  const stringified = stringify(obj);
  if (typeof Blob !== 'undefined') return new Blob([stringified]).size;
  return Buffer.byteLength(stringified, 'utf8');
};

const consoleMethods = ['log', 'error', 'debug', 'warn', 'info'];
let cachedConsole: any = consoleMethods.reduce((a: any, method: string) => {
  a[method] = console[method];
  return a;
}, {});
const originalConsole: {
  [level: string]: (...args: any[]) => void;
} = consoleMethods.reduce((a: any, m: string) => {
  a[m] = (...args: any) => {
    cachedConsole[m](...args);
  };
  return a;
}, {});

// This will delay the caching of the original instance of the console
// until after logdna is enabled and initialized for use with SSR.
const cacheConsole = () => {
  const { log, error, debug, warn, info } = console;
  cachedConsole = { log, error, debug, warn, info };
};
cacheConsole();

export default {
  jsonByteSize,
  validateHostname,
  parseTags,
  stringify,
  getStackTrace,
  backOffWithJitter,
  originalConsole,
};
