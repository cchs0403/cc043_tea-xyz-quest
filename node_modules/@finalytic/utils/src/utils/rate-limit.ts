import { ms } from './time';

export class RateLimitAbortError extends Error {
  constructor() {
    super('Throttled function aborted');
    this.name = 'AbortError';
  }
}

export interface RateLimitOptions {
  /**
	The maximum number of calls within an `interval`.
	*/
  readonly limit?: number;
  /**
	The timespan for `limit` in milliseconds.
	*/
  readonly interval?: number | string;
}

export function rateLimit({ limit, interval: i }: RateLimitOptions) {
  if (!limit || !i) {
    return <Argument extends readonly unknown[], R>(
      fn: (...args: Argument) => Promise<R>
    ) => {
      return (...args: Argument): Promise<R> => fn(...args);
    };
  }

  const interval = typeof i === 'string' ? ms(i) : i;
  if (!Number.isFinite(limit)) {
    throw new TypeError('Expected `limit` to be a finite number');
  }

  if (!Number.isFinite(interval)) {
    throw new TypeError('Expected `interval` to be a finite number');
  }

  const queue = new Map();

  let currentTick = 0;
  let activeCount = 0;

  function windowedDelay() {
    const now = Date.now();

    if (now - currentTick > interval) {
      activeCount = 1;
      currentTick = now;
      return 0;
    }

    if (activeCount < (limit || 0)) {
      activeCount++;
    } else {
      currentTick += interval;
      activeCount = 1;
    }

    return currentTick - now;
  }

  return <Argument extends readonly unknown[], R>(
    fn: (...args: Argument) => Promise<R>
  ) => {
    const throttled = (...args: Argument): Promise<R> => {
      if (!throttled.isEnabled) {
        return (async () => fn(...args))();
      }

      let timeout: NodeJS.Timeout | Timer;
      return new Promise((resolve, reject) => {
        const execute = () => {
          resolve(fn(...args));
          queue.delete(timeout);
        };

        timeout = setTimeout(execute, windowedDelay());

        queue.set(timeout, reject);
      });
    };

    throttled.abort = () => {
      for (const timeout of queue.keys()) {
        clearTimeout(timeout);
        queue.get(timeout)(new RateLimitAbortError());
      }
      queue.clear();
    };

    throttled.isEnabled = true;

    return throttled;
  };
}
