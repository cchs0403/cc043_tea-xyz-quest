import { sum } from '../array';

function cartesian(args: number[][]) {
  if (args.length === 0) return [];
  const r: number[][] = [];
  const max = args.length - 1;
  function helper(arr: number[], i: number) {
    for (let j = 0, l = args[i].length; j < l; j++) {
      const a = arr.slice(0); // clone arr
      a.push(args[i][j]);
      if (i === max) r.push(a);
      else helper(a, i + 1);
    }
  }
  helper([], 0);
  return r;
}

export function findInMatrix<
  T extends {
    [s: string]: number[] | undefined;
  },
  TResult extends Partial<{
    [s in keyof T]: number;
  }>,
>(
  amount: number,
  lineItemMatrix: T,
  tolerance?: number
): { absoluteOffset: number; offset: number; state: TResult } | undefined {
  let result:
    | {
        absoluteOffset: number;
        offset: number;
        combination: number[];
      }
    | undefined = undefined;
  const values = Object.entries(lineItemMatrix)
    .filter(([, value]) => value)
    .map(([key, value]) => [key as keyof T, value!] as const);
  const combinations = cartesian(values.map(([, value]) => value));
  for (const combination of combinations) {
    const total = sum(combination);
    const offset = amount - total;
    const absoluteOffset = Math.abs(offset);
    if (!result || absoluteOffset < result.absoluteOffset) {
      result = {
        offset,
        absoluteOffset,
        combination,
      };
      if (absoluteOffset === 0) break;
    }
  }
  if (!result)
    return { absoluteOffset: amount, offset: amount, state: {} as TResult };
  if (tolerance && result.absoluteOffset > tolerance)
    throw new Error('No combination found');
  return {
    absoluteOffset: result.absoluteOffset,
    offset: result.offset,
    state: values.reduce((state, [key], i) => {
      const value = result?.combination[i];
      if (value || value === 0) state[key] = value as any;
      return state;
    }, {} as TResult),
  };
}
