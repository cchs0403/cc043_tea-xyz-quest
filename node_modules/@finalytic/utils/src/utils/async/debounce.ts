import { type Duration, ms } from '../time';

export function debounce<T extends (...args: any[]) => void>(
  func: T,
  delay?: number
  //immediate?: boolean
): T & {
  cache: Record<
    string,
    { time: number; id: string | number | NodeJS.Timeout | undefined }
  >;
};
export function debounce<T extends (...args: any[]) => void>(
  delay?: number
  //immediate?: boolean
): ((func: T, key: string) => T) & {
  cache: Record<
    string,
    { time: number; id: string | number | NodeJS.Timeout | undefined }
  >;
};
export function debounce<T extends (...args: any[]) => void>(
  funcOrDelay: any,
  delayOrImmediate?: any
  //immediateOrNull?: any
): any {
  if (typeof funcOrDelay === 'function') {
    const func = funcOrDelay;
    const delay = delayOrImmediate;
    // const immediate = immediateOrNull;
    // debounce(delay, immediate)(func, '');
    return debounce(delay)(func, '');
  }
  const delay = funcOrDelay;
  const immediate = delayOrImmediate;
  const cache: Record<
    string,
    {
      time: number;
      id: string | number | NodeJS.Timeout | Timer | undefined;
    }
  > = {};
  const fn = (func: T, key: string) => {
    const fn = (...args: Parameters<T>) => {
      cache[key] = cache[key] || ({} as any);
      cache[key].time = +new Date();
      if (!cache[key].id && immediate) {
        func(...args);
      }
      clearTimeout(cache[key].id as any);
      cache[key].id = setTimeout(() => {
        delete cache[key];
        func(...args);
      }, delay);
    };
    fn.cache = cache;
    return fn;
  };
  fn.cache = cache;
  return fn;
}

export function throttle<T extends (...args: any[]) => void>(
  func: T,
  duration: Duration = '1s'
) {
  let lastTime = 0;
  const timeFrame = ms(duration);
  return (...args: Parameters<T>) => {
    const now = +new Date();
    if (now - lastTime >= timeFrame) {
      func(...args);
      lastTime = now;
    }
  };
}
