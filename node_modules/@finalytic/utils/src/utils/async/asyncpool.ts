export async function* asyncPool<T, TRes>(
  iterable: T[],
  iteratorFn: (item: T, items: T[]) => Promise<TRes>,
  concurrency: number
): AsyncIterable<T> {
  const executing = new Set<any>();
  async function consume() {
    const [promise, value] = await Promise.race(executing);
    executing.delete(promise);
    return value;
  }
  for (const item of iterable) {
    const promise = (async () => await iteratorFn(item, iterable))().then(
      (value) => [promise, value]
    );
    executing.add(promise);
    if (executing.size >= concurrency) {
      yield await consume();
    }
  }
  while (executing.size) {
    yield await consume();
  }
}

asyncPool.all = async function all<T, TRes>(
  iterable: T[],
  iteratorFn: (item: T, items: T[]) => Promise<TRes>,
  concurrency: number
) {
  const results: T[] = [];
  for await (const result of asyncPool<T, TRes>(
    iterable,
    iteratorFn,
    concurrency
  )) {
    results.push(result);
  }
  return results;
};
