import blake from 'blakejs/blake2b';
import tweetnacl from 'tweetnacl';
import tweetnaclUtils from 'tweetnacl-util';
const { box, randomBytes, secretbox } = tweetnacl;
const { decodeBase64, decodeUTF8, encodeBase64, encodeUTF8 } = tweetnaclUtils;

const newNonce = (length = secretbox.nonceLength) => randomBytes(length);

export class SymmetricCrypto {
  static fromPassphrase(secret: string) {
    return new SymmetricCrypto(hash([decodeUTF8(secret)], secretbox.keyLength));
  }
  static fromSecretKey(key: string | Uint8Array) {
    return new SymmetricCrypto(key);
  }
  static fromNew() {
    return new SymmetricCrypto();
  }
  get secretKey() {
    return encodeBase64(this._secretKey);
  }
  private _secretKey: Uint8Array;
  // private _sharedKeys: { [key: string]: Uint8Array };
  constructor(secretKey?: Uint8Array | string) {
    // this._sharedKeys = {};
    if (typeof secretKey === 'string') {
      this._secretKey = decodeBase64(secretKey);
    } else if (secretKey) {
      this._secretKey = secretKey;
    } else {
      this._secretKey = newNonce(secretbox.keyLength);
    }
  }
  static async seal(json: any, secretKey: Uint8Array | string) {
    const crypto =
      typeof secretKey === 'string'
        ? SymmetricCrypto.fromPassphrase(secretKey)
        : SymmetricCrypto.fromSecretKey(secretKey);
    const result = await crypto.seal(json);
    crypto.destroy();
    return result;
  }
  async seal(json: any) {
    const nonce = newNonce();
    const messageUint8 = decodeUTF8(JSON.stringify(json));
    const box = secretbox(messageUint8, nonce, this._secretKey);

    const fullMessage = new Uint8Array(nonce.length + box.length);
    fullMessage.set(nonce);
    fullMessage.set(box, nonce.length);

    const base64FullMessage = encodeBase64(fullMessage);
    return base64FullMessage;
  }
  async open(messageWithNonce: string) {
    const messageWithNonceAsUint8Array = decodeBase64(messageWithNonce);
    const nonce = messageWithNonceAsUint8Array.slice(0, secretbox.nonceLength);
    const message = messageWithNonceAsUint8Array.slice(
      secretbox.nonceLength,
      messageWithNonce.length
    );

    const decrypted = secretbox.open(message, nonce, this._secretKey);

    if (!decrypted) {
      throw new Error('Could not decrypt message');
    }

    const base64DecryptedMessage = encodeUTF8(decrypted);
    return JSON.parse(base64DecryptedMessage);
  }
  destroy() {
    zero(this._secretKey);
  }
}

export class AsymmetricCrypto {
  static fromSecret(secret: string) {
    return new AsymmetricCrypto(
      hash([decodeUTF8(secret)], box.secretKeyLength)
    );
  }
  static fromBase64(key: string) {
    return new AsymmetricCrypto(key);
  }
  static fromEmpty() {
    return new AsymmetricCrypto();
  }
  static fromArray(key: Uint8Array) {
    return new AsymmetricCrypto(key);
  }
  get publicKey() {
    return encodeBase64(this._publicKey);
  }
  set publicKey(value: string) {
    this._publicKey = decodeBase64(value);
  }
  get secretKey() {
    return encodeBase64(this._secretKey);
  }
  private _publicKey: Uint8Array;
  private _secretKey: Uint8Array;
  // private _sharedKeys: { [key: string]: Uint8Array };
  constructor(secretKey?: Uint8Array | string) {
    // this._sharedKeys = {};
    if (typeof secretKey === 'string') {
      secretKey = decodeBase64(secretKey);
    }
    const pair = secretKey
      ? box.keyPair.fromSecretKey(secretKey)
      : box.keyPair();
    this._publicKey = pair.publicKey;
    this._secretKey = pair.secretKey;
  }
  static async seal(json: any, publicKey: Uint8Array | string) {
    const crypto = AsymmetricCrypto.fromEmpty();
    const result = await crypto.seal(json, publicKey);
    crypto.destroy();
    return result;
  }
  async seal(json: any, publicKey: Uint8Array | string) {
    if (typeof publicKey === 'string') {
      publicKey = decodeBase64(publicKey);
    }
    const nonce = hash([this._publicKey, publicKey]);
    const messageUint8 = decodeUTF8(JSON.stringify(json));
    const encrypted = box(messageUint8, nonce, publicKey, this._secretKey);

    const fullMessage = new Uint8Array(
      this._publicKey.length + encrypted.length
    );
    fullMessage.set(this._publicKey);
    fullMessage.set(encrypted, this._publicKey.length);

    return encodeBase64(fullMessage);
  }
  async open(messageWithNonce: string) {
    const messageWithNonceAsUint8Array = decodeBase64(messageWithNonce);
    const publicKey = messageWithNonceAsUint8Array.subarray(
      0,
      box.publicKeyLength
    );
    const nonce = hash([publicKey, this._publicKey]);
    const message = messageWithNonceAsUint8Array.subarray(box.publicKeyLength);

    const decrypted = box.open(message, nonce, publicKey, this._secretKey);

    // console.log("public/secret key", this._publicKey, this._secretKey)
    if (!decrypted) {
      throw new Error('Could not decrypt message');
    }

    const base64DecryptedMessage = encodeUTF8(decrypted);
    return JSON.parse(base64DecryptedMessage);
  }
  destroy() {
    zero(this._secretKey);
    zero(this._publicKey);
  }
}

function zero(buf: Uint8Array) {
  for (let i = 0; i < buf.length; i++) {
    buf[i] = 0;
  }
}

function hash(keys: Uint8Array[], nonceLength = box.nonceLength) {
  const state = blake.blake2bInit(nonceLength, null);
  for (const key of keys) {
    blake.blake2bUpdate(state, key);
  }
  return blake.blake2bFinal(state);
}
/*
(async () => {
})();
*/
